<!DOCTYPE html>
<html>
<head>
    <title>Pose Estimation</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }

        #video, #canvas {
            position: absolute;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
        }

        #video {
            z-index: 1;
        }

        #canvas {
            z-index: 2;
            background: transparent;
        }
    </style>
</head>
<body>
    <video id="video" width="640" height="480" autoplay muted></video>
    <canvas id="canvas" width="640" height="480"></canvas>
    
    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');

        // MediaPipe Pose 설정
        const pose = new Pose({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
            }
        });

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            smoothSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        navigator.mediaDevices.getUserMedia({video: true})
            .then((stream) => {
                videoElement.srcObject = stream;

                // 비디오 스트림이 준비되었을 때 play() 호출
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                };
            })
            .catch((error) => {
                console.error('웹캠 접근 에러:', error);
            });

        // 결과 처리 함수
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);


            // 랜드마크 그리기
            if (results.poseLandmarks) {
                for (const landmark of results.poseLandmarks) {
                    // 여기에서 원하는 랜드마크 ID에 대한 로직을 구현하세요.
                    drawLandmark(canvasCtx, landmark);
                }
            }

            canvasCtx.restore();
        }

        function drawLandmark(ctx, landmark) {
            const x = landmark.x * canvasElement.width;
            const y = landmark.y * canvasElement.height;

            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "red";
            ctx.fill();
        }


        // 웹캠에서 포즈 감지
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        camera.start();
    </script>
</body>
</html>
